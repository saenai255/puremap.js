(()=>{function e(e,r){return Object.keys(r).forEach((function(t){"default"===t||"__esModule"===t||e.hasOwnProperty(t)||Object.defineProperty(e,t,{enumerable:!0,get:function(){return r[t]}})})),e}function r(e){Object.defineProperty(e,"__esModule",{value:!0,configurable:!0})}function t(e,r,t,n){Object.defineProperty(e,r,{get:t,set:n,enumerable:!0,configurable:!0})}var n={},o={};r(o),t(o,"default",(()=>_));var s={};r(s),t(s,"OptionUnwrapError",(()=>p)),t(s,"isSome",(()=>h)),t(s,"isNone",(()=>m)),t(s,"None",(()=>d)),t(s,"Some",(()=>b)),t(s,"default",(()=>w));var i={};function c(...e){return r=>e.reduce(((e,r)=>r(e)),r)}r(i),t(i,"compose",(()=>c)),t(i,"default",(()=>u));var u={$:c,debug:(e,r=((e,r,t)=>console.log(e,t,r)))=>t=>(r("pipe.debug",t,e||""),t)};const a=Symbol("Option"),l=Symbol("None"),f=Symbol("Some");class p extends Error{}const h=e=>a in e&&e[a]===f,m=e=>a in e&&e[a]===l,d=()=>({[a]:l});function b(e){return"object"==typeof e&&a in e?e:{[a]:f,[f]:e}}const g=e=>h(e)?e[f]:(()=>{throw new p})(),y=e=>g(e);var w={map:function(e){return r=>h(r)?b(e(y(r))):d()},of:(e,r={})=>r.allowNull&&null===e||r.allowUndefined&&void 0===e||null!=e?b(e):d(),unwrap:g,get:y,$:function(...e){return w.map(u.$(...e))}},v={};r(v),t(v,"ResultUnwrapError",(()=>O)),t(v,"Err",(()=>R)),t(v,"Ok",(()=>S)),t(v,"isOk",(()=>L)),t(v,"isErr",(()=>P)),t(v,"default",(()=>N));const E=Symbol("result"),$=Symbol("error"),j=Symbol("ok");class O extends Error{constructor(e,r){super(r),this.uncaught=e}}const R=e=>({[E]:$,[$]:e}),S=e=>({[E]:j,[j]:e}),L=e=>E in e&&e[E]===j,P=e=>E in e&&e[E]===$,A=()=>e=>L(e)?e[j]:(()=>{throw new O(e[$])})(),k=()=>e=>A()(e),x=()=>e=>{return P(r=e)?r[$]:(()=>{throw new O(r[j])})();var r},M=e=>{try{return S(e())}catch(e){return R(e)}};var N={unwrap:A,getOk:k,getErr:x,of:M,map:function(e){return r=>L(r)?M((()=>e(k()(r)))):R(r[$])},mapErr:function(e){return r=>P(r)?R(e(x()(r))):r},$:function(...e){return N.map(u.$(...e))},$Err:function(...e){return N.mapErr(u.$(...e))},merge:()=>e=>L(e)?k()(e):x()(e)};const U={asc:(e,r)=>{if(typeof e!=typeof r)throw new Error(`Sort Error. Left and right elements are not the same type. Left is ${e} and right is ${r}`);if("number"==typeof e)return e-r;if("boolean"==typeof e)return Number(e)-Number(r);if("string"==typeof e)return e.localeCompare(r);throw new Error("Unreachable")},desc:(e,r)=>-1*U.asc(e,r)};var _={map:e=>r=>r.map(e),filter:e=>r=>r.filter(e),find:e=>r=>w.of(r.find(e)),some:e=>r=>r.some(e),every:e=>r=>r.every(e),sort:(e=U.asc,r)=>t=>r?r([...t],e):[...t].sort(e),sorter:U,append:e=>r=>[...r,e],debug:(e="")=>r=>(r.forEach(((r,t)=>console.log(`debug${e?`[${e}]`:""}[${t}] =`,r))),[...r]),divBy:e=>r=>r.map((r=>0===e?R(new Error("division by zero")):N.of((()=>r/e)))),divOf:e=>r=>r.map((r=>0===r?R(new Error("division by zero")):N.of((()=>e/r)))),first:()=>e=>0===e.length?d():b(e[0]),flat:()=>e=>e.flat(),flatMap:e=>r=>r.flatMap(e),foldl:(e,r)=>t=>0===t.length?r:t.reduce(e,t.at(0)),foldr:(e,r)=>t=>0===t.length?r:t.slice(0,-1).reduceRight(e,t.at(t.length-1)),reduce:(e,r)=>t=>t.reduce(e,r),reduceRight:(e,r)=>t=>t.reduceRight(e,r),last:()=>e=>0===e.length?d():b(e.at(e.length-1)),prepend:e=>r=>[e,...r],join:(e="")=>r=>r.join(e),reverse:()=>e=>[...e].reverse(),isEmpty:()=>e=>0===e.length,sum:()=>e=>e.reduce(((e,r)=>r+e),0),product:()=>e=>e.reduce(((e,r)=>r*e),1),pow:e=>r=>r.map((r=>Math.pow(r,e))),powOf:e=>r=>r.map((r=>Math.pow(e,r))),tuple:(e=2)=>r=>{const t=[];for(let n=0;n<r.length;n+=e){const o=r.slice(n,n+e).map(b);for(;o.length<e;)o.push(d());t.push(o)}return t},fromString:e=>r=>r.split(e),shiftr:(e=1)=>([...r])=>{if(0===r.length)return r;const t=e%r.length;return[...r.slice(r.length-t,r.length),...r.slice(0,r.length-t)]},shiftl:(e=1)=>([...r])=>{if(0===r.length)return r;const t=e%r.length;return[...r.slice(r.length-t,r.length),...r.slice(0,r.length-t)]},concat:e=>r=>[...r,...e],unique:()=>e=>{const r=[];for(const t of e){r.some((e=>e===t))||r.push(t)}return r},uniqueBy:e=>r=>{const t=[];for(const n of r){t.some((r=>e(r,n)))||t.push(n)}return t},between:(e,r)=>t=>t.filter((t=>t>e&&t<r)),betweenEq:(e,r)=>t=>t.filter((t=>t>=e&&t<=r)),gt:e=>r=>r.filter((r=>r>e)),lt:e=>r=>r.filter((r=>r<e)),gte:e=>r=>r.filter((r=>r>=e)),lte:e=>r=>r.filter((r=>r<=e)),toObject:(e=((e,r)=>r))=>r=>r.map(((r,t)=>({[e(r,t)]:r}))).reduce(((e,r)=>({...e,...r})),{}),fromObject:e=>r=>Object.entries(r).map((([r,t])=>[e(r),t])).sort((([e],[r])=>e-r)).map((([e,r])=>r))},q={};r(q),t(q,"AsyncResultUnwrapError",(()=>C)),t(q,"AsyncErr",(()=>T)),t(q,"AsyncOk",(()=>D)),t(q,"isAsyncOk",(()=>H)),t(q,"isAsyncErr",(()=>I)),t(q,"default",(()=>K));class z{listeners=[];done=!1;once(e){this.done?e():this.listeners.push(e)}fire(){this.done=!0,this.listeners.forEach((e=>e())),this.listeners=[]}static nextLoop(e){const r=new z;return r.once(e),setTimeout((()=>r.fire())),r}}const B=Symbol("async-result"),F=Symbol("error"),G=Symbol("ok");class C extends Error{constructor(e,r){super(r),this.uncaught=e}}const T=e=>{const r={[B]:{done:!1,observer:z.nextLoop((()=>{r[B][F]=e,r[B].done=!0}))}};return r},D=e=>{const r={[B]:{done:!1,observer:z.nextLoop((()=>{r[B][G]=e,r[B].done=!0}))}};return r},H=()=>e=>"object"==typeof e&&B in e?new Promise((r=>{e[B].observer.once((()=>{const t=G in e[B];r([t,e])}))})):Promise.reject(new Error(`Given parameter ${e} is not a valid AsyncResult`)),I=()=>e=>"object"==typeof e&&B in e?new Promise((r=>{e[B].observer.once((()=>{const t=F in e[B];r([t,e])}))})):Promise.reject(new Error(`Given parameter ${e} is not a valid AsyncResult`)),J=async e=>{const[r,t]=await H()(e);return r?t[B][G]:Promise.reject(t[B][F])};var K={map:function(e){return r=>{const t=r[B],n={[B]:{done:!1,observer:new z}};return t.observer.once((()=>{if(G in t)try{const r=e(t[G]);"object"==typeof r&&B in r?r[B].observer.once((()=>{G in r[B]?n[B][G]=r[B][G]:n[B][F]=r[B][F],n[B].done=!0,n[B].observer.fire()})):(n[B][G]=r,n[B].done=!0,n[B].observer.fire())}catch(e){n[B][F]=e,n[B].done=!0,n[B].observer.fire()}else n[B][F]=t[F],n[B].done=!0,n[B].observer.fire()})),n}},mapErr:function(e){return r=>{const t=r[B],n={[B]:{done:!1,observer:new z}};return t.observer.once((()=>{if(F in t)try{const r=e(t[F]);"object"==typeof r&&B in r?r[B].observer.once((()=>{F in r[B]?n[B][F]=r[B][F]:n[B][G]=r[B][G],n[B].done=!0,n[B].observer.fire()})):(n[B][F]=r,n[B].done=!0,n[B].observer.fire())}catch(e){n[B][G]=t[G],n[B].done=!0,n[B].observer.fire()}else n[B][G]=t[G],n[B].done=!0,n[B].observer.fire()})),n}},of:e=>{const r={[B]:{done:!1,observer:new z}};return e().then((e=>{r[B][G]=e})).catch((e=>{r[B][F]=e})).finally((()=>{r[B].done=!0,r[B].observer.fire()})),r},getAsyncOk:e=>J(e),getAsyncErr:e=>(async e=>{const[r,t]=await I()(e);return r?t[B][F]:Promise.reject(t[B][G])})(e),unwrap:J,$:function(...e){return K.map(u.$(...e))},$AsyncErr:function(...e){return K.mapErr(u.$(...e))},merge:()=>e=>new Promise((async r=>{await H()(e)?e[B].observer.once((()=>r(e[B][G]))):e[B].observer.once((()=>r(e[B][F])))}))},Q={};r(Q),t(Q,"Right",(()=>Z)),t(Q,"Left",(()=>ee)),t(Q,"isRight",(()=>re)),t(Q,"isLeft",(()=>te)),t(Q,"default",(()=>ce));const V=Symbol("Either"),W=Symbol("Left"),X=Symbol("Right");class Y extends Error{constructor(e){super(e)}}const Z=e=>({[V]:X,[X]:e}),ee=e=>({[V]:W,[W]:e}),re=e=>V in e&&e[V]===X,te=e=>V in e&&e[V]===W,ne=()=>e=>re(e)?e[X]:(()=>{throw new Y("Failed to unwrapRight because the given parameter was Either$Left")})(),oe=()=>e=>te(e)?e[W]:(()=>{throw new Y("Failed to unwrapLeft because the given parameter was Either$Right")})(),se=()=>e=>ne()(e),ie=()=>e=>oe()(e);var ce={unwrapRight:ne,unwrapLeft:oe,getLeft:ie,getRight:se,mapRight:function(e){return r=>re(r)?Z(e(se()(r))):r},mapLeft:function(e){return r=>te(r)?ee(e(ie()(r))):r},$Left:function(...e){return ce.mapLeft(u.$(...e))},$Right:function(...e){return ce.mapRight(u.$(...e))},merge:()=>e=>te(e)?ie()(e):se()(e)};e(n,o),e(n,q),e(n,v),e(n,Q),e(n,s),e(n,i)})();
//# sourceMappingURL=index.js.map
